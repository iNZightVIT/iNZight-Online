{
    "contents" : "library(pROC)\nlibrary(biomaRt)\nlibrary(speedglm)\n\n# The main analysis function for GWPS\ngwps.analysis = function(gwps,p.ways,out.dir=getwd(),log.regr.pval.cutoff=0.05,\n                         add.downstream=0,add.upstream=0,min.snps.per.gene=10,\n                         max.num.genes=NULL){\n  SNP.info = get.SNP.info(gwps)\n  snp.sets.per.gene = map.SNPS(p.ways,SNP.info,add.downstream,add.upstream)\n  to.analyse = do.call(rbind,lapply(1:length(snp.sets.per.gene),get.gene.data,\n                                    snp.sets.per.gene,\n                                    gwps,\n                                    SNP.info,\n                                    min.snps.per.gene,\n                                    chrs=p.ways@chromosome))\n#   load(file=\"/media/christoph/0357FCFC5DF93E00/to.analyse.Rdata\")\n#   load(file=\"/media/christoph/0357FCFC5DF93E00/snp.sets.per.gene.Rdata\")\nresults = do.call(rbind,lapply(1:100,pathway.analyse,\n                               p.ways,\n                               gwps,\n                               SNP.info,\n                               snp.sets.per.gene,\n                               to.analyse,\n                               log.regr.pval.cutoff,\n                               out.dir,\n                               max.num.genes))\nsystem.time({results = do.call(rbind,lapply(1:100,pathway.analyse,\n                               p.ways,\n                               gwps,\n                               SNP.info,\n                               snp.sets.per.gene,\n                               to.analyse,\n                               log.regr.pval.cutoff,\n                               out.dir,\n                               max.num.genes))})\n}\n\n# analyse a single pathway at index \"index' in the p.ways object\npathway.analyse = function(index,p.ways,gwps,SNP.info,snp.sets.per.gene,to.analyse,log.regr.pval.cutoff,\n                           out.dir,max.num.genes){\n  num.group.1 = ncol(gwps@cohort1@map)\n  type.group.1 = gwps@cohort1@type\n  num.group.2 = ncol(gwps@cohort2@map)\n  type.group.2 = gwps@cohort2@type\n  columnnames = c(\"gene.set.name\",\n                  \"t.test.pvalue\",\n                  \"uniformity.test.pvalue\",\n                  \"ind.total\",\n                  \"control.total\",\n                  \"case.total\",\n                  \"genes.in.set\",\n                  \"genes.with.SNPs\",\n                  \"genes.used.in.reg.model\",\n                  paste(\"T\",type.group.1,sep=\".\"),\n                  paste(\"F\",type.group.1,sep=\".\"),\n                  paste(\"F\",type.group.2,sep=\".\"),\n                  paste(\"T\",type.group.2,sep=\".\"),\n                  \"sensitivity\",\n                  \"specifity\",\n                  \"precission\",\n                  \"negative.predictive.value\",\n                  \"fall.out\",\n                  \"FDR\",\n                  \"false.negative.rate\",\n                  \"accuracy\",\n                  \"F1.score\",\n                  \"matthews.correlation.coefficient\",\n                  \"informedness\",\n                  \"markedness\",\n                  \"geometric.mean\",\n                  \"AUC\")\n  result = data.frame(matrix(rep(NA,27),nrow=1))\n  colnames(result) = columnnames\n  genes = readRDS(file=p.ways@access.pathway[index])\n  result[1,1] = genes[[1]]\n  genes = genes[[2]]\n  indexes = which(genes%in%p.ways@genes.symbols|genes%in%p.ways@entrez.id)\n  p.way.data = to.analyse[which(as.numeric(rownames(to.analyse))%in%indexes),]\n  p.way.data.transform = t(p.way.data)\n  if(is.null(max.num.genes)|max.num.genes>=nrow(p.way.data)){\n    lrfit = fit.model1(type.group.1,type.group.2,num.group.1,num.group.2,p.way.data.transform,log.regr.pval.cutoff)\n  }else{\n    lrfit=NULL\n  }\n  if(!is.null(lrfit)){\n    t.test.data = colSums(p.way.data)/nrow(p.way.data) # sum of all columns divided by the number of genes in the gene set\n    result[1,2] = t.test(x=t.test.data[1:num.group.1],\n                         y=t.test.data[(num.group.1+1):(num.group.1+num.group.2)],\n                         alternative=\"two.sided\")[[\"p.value\"]]\n    png(file=paste(out.dir,\"/\",result[1,1],\".t.test.qq.png\",sep=\"\"),width=600, height=600)\n    pTitle = paste(\"QQ-plot:\",result[1,1])\n    qqplot(t.test.data[1:num.group.1],\n           t.test.data[(num.group.1+1):(num.group.1+num.group.2)],\n           main = pTitle, xlab=paste(type.group.1,\" (\",num.group.1,\")\",sep=\"\"), \n           ylab=paste(type.group.2,\" (\",num.group.2,\")\",sep=\"\"))\n    lines(c(0, max(max(t.test.data[(num.group.1+1):(num.group.1+num.group.2)]),\n                   max(t.test.data[1:num.group.1]))), \n          c(0, max(max(t.test.data[1:num.group.1]),\n                   max(t.test.data[(num.group.1+1):(num.group.1+num.group.2)]))), lwd = 2, col = \"red\")\n    dev.off()\n    png(file=paste(out.dir,\"/\",result[1,1],\".t.test.box.plot.png\",sep=\"\"), width=600, height=600)\n    pTitle = paste(\"Total Score Frequency of Cohorts:\", result[1,1] )\n    boxplot(list(t.test.data[1:num.group.1],t.test.data[(num.group.1+1):(num.group.1+num.group.2)]),\n            names=c(type.group.1,type.group.2),ylab=\"Cohort Total Scores\", main=pTitle,col=c(\"light green\",\"light blue\"))\n    dev.off()\n    SNPs.in.Pathway = unlist(snp.sets.per.gene[indexes])\n    result[1,3] = suppressWarnings(ks.test(x=SNP.info[which(SNP.info$rsid%in%SNPs.in.Pathway),\"p.values\"],\n                          y=\"punif\")$p.value)# if there are several equal p-values this will throw a warning.\n    png(file=paste(out.dir,\"/\",result[1,1],\".uniformity.hist.plot.png\",sep=\"\"), width=600, height=600)\n    pTitle = paste(\"Gene set:\", result[1,1] )\n    hist(SNP.info[which(SNP.info$rsid%in%SNPs.in.Pathway),\"p.values\"], main=pTitle,xlab=\"Probabilities\",\n         col=\"light grey\",breaks=seq(from=0,to=1,by=0.05))\n    dev.off()\n  #   system.time({# simple test for speed\n  #     lrfit = fit.model1(type.group.1,type.group.2,num.group.1,num.group.2,p.way.data.transform,log.regr.pval.cutoff)\n  #     })\n  #    user  system elapsed \n  #   0.565   0.033   0.599 \n  #   system.time({# simple test for speed\n  #     lrfit = fit.model2(type.group.1,type.group.2,num.group.1,num.group.2,p.way.data.transform,log.regr.pval.cutoff)\n  #     })\n  #    user  system elapsed \n  #   9.054   0.228   9.294 \n  #   system.time({# simple test for speed\n  #     lrfit = fit.model3(type.group.1,type.group.2,num.group.1,num.group.2,p.way.data.transform,log.regr.pval.cutoff)\n  #   })\n  #      user  system elapsed \n  #   248.603   1.746 251.833 \n    coeffs = coef(summary(lrfit))\n  #   resis2 = predict(lrfit)\n    colnames(p.way.data.transform) = paste(\"X\",colnames(p.way.data.transform),sep=\"\")\n    resis2 = unlist(lapply(1:nrow(p.way.data.transform),function(ind,intercept,data,predictors){\n      if(is.null(dim(data))&length(data)!=0){\n        row = data[ind]\n      }else{\n        row = data[ind,]\n      }\n      sum(c(intercept,(row*predictors)))\n    },coeffs[1,1],p.way.data.transform[,which(colnames(p.way.data.transform)%in%rownames(coeffs))],coeffs[-1,1]))\n    conf.mat = matrix(rep(0,4),nrow=2)\n    colnames(conf.mat) = c(\"pred.control\",\"pred.case\")\n    rownames(conf.mat) = c(\"true.control\",\"true.case\")\n    conf.mat[1,1] = length(which(response%in%type.group.1&resis2>0))\n    conf.mat[1,2] = length(which(response%in%type.group.1&resis2<0))\n    conf.mat[2,1] = length(which(response%in%type.group.2&resis2>0))\n    conf.mat[2,2] = length(which(response%in%type.group.2&resis2<0))\n    result[1,4] = nrow(p.way.data.transform) # total number of individuals\n    result[1,5] = num.group.1 # number individuals in control\n    result[1,6] = num.group.2 # number individuals in case\n    result[1,7] = length(genes) # # genes in set\n    result[1,8] = ncol(p.way.data.transform) # # genes with SNPs\n    result[1,9] = nrow(coeffs)-1 # # genes used in model\n    TN = as.numeric(length(which(response%in%type.group.1&resis2>0)))\n    FP = as.numeric(length(which(response%in%type.group.1&resis2<0)))\n    FN = as.numeric(length(which(response%in%type.group.2&resis2>0)))\n    TP = as.numeric(length(which(response%in%type.group.2&resis2<0)))\n    result[1,10] = TN # TN\n    result[1,11] = FP # FP\n    result[1,12] = FN # FN\n    result[1,13] = TP # TP\n    result[1,14] = TP/(TP+FN) # sensitivity\n    result[1,15] = TN/(TN+FP) # Specifity\n    result[1,16] = TP/(TP+FP) # precision\n    result[1,17] = TN/(TN+FN) # negative.predictive.value\n    result[1,18] = FP/(FP+TN) # fall.out\n    result[1,19] = FP/(FP+TP) # FDR\n    result[1,20] = FN/(FN+TP) # false.negative.rate\n    result[1,21] = (TP+TN)/result[1,4] # accuracy\n    result[1,22] = (2*TP)/(2*TP+FP+FN) # F1 score\n    result[1,23] = (TP*TN-FP*FN)/\n                   sqrt(((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN))) # matthews.correlation.coefficient\n    result[1,24] = result[1,11] + result[1,12] - 1 # Informedness\n    result[1,25] = result[1,13] + result[1,14] -1 # Markedness\n    result[1,26] = sqrt(((TP/(FN+TP))*(TN/(TN+FP)))) # geometric mean\n    png(file=paste(out.dir,\"/\",result[1,1],\".ROC.png\",sep=\"\"))\n    temp = suppressWarnings(roc(response,\n                                resis2, percent=F,\n                                # arguments for auc\n                                response=response,\n                                predictor=resis2,\n                                # arguments for ci\n                                ci=TRUE, boot.n=100, ci.alpha=0.9, stratified=FALSE,\n                                # arguments for plot\n                                plot=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE,\n                                grid=TRUE,print.auc=TRUE, show.thres=TRUE,\n                                main=paste(\"Gene set: \",result[1,1],\"; geometric mean: \",round(result[1,23],2),sep=\"\")))\n    dev.off()\n    result[1,27] = temp$auc\n    saved = list(p.way.data=p.way.data,\n                 t.test.vars=list(x=t.test.data[1:num.group.1],\n                                  y=t.test.data[(num.group.1+1):(num.group.1+num.group.2)]),\n                 uniformity.test=SNP.info[which(SNP.info$rsid%in%SNPs.in.Pathway),\"p.values\"],\n                 logit.reg=list(log.regr.pval.cutoff=log.regr.pval.cutoff,\n                                lrfit=lrfit,\n                                conf.mat=conf.mat,\n                                ROC=temp),\n                 result=result)\n    saveRDS(saved,file=paste(out.dir,\"/\",result[1,1],\".RDS\",sep=\"\"))\n  }else{\n    result = NULL\n  }\n  result\n}\n\n# first and simple strategy to fit a model to the gene set data\n# simplified backward elimination\nfit.model1 = function(type.group.1,\n                      type.group.2,\n                      num.group.1,\n                      num.group.2,\n                      p.way.data.transform,\n                      log.regr.pval.cutoff){\n  response = c(rep(type.group.1,num.group.1),rep(type.group.2,num.group.2))\n  p.way.data.transform=cbind(response,data.frame(p.way.data.transform))\n  if(num.group.1>num.group.2){\n    weights = c(rep(num.group.2/num.group.1,num.group.1),rep(1,num.group.2))\n  }else if(num.group.1<num.group.2){\n    weights = c(rep(1,num.group.1),rep(num.group.1/num.group.2,num.group.2))\n  }else{\n    weights = rep(1,num.group.1+num.group.2)\n  }\n  fo = as.formula(paste(\"response ~ \",paste(colnames(p.way.data.transform)[-1],collapse=\" + \")))\n  lrfit = suppressWarnings(speedglm(fo,data=p.way.data.transform,family=binomial(logit),weights=weights))\n  probs = suppressWarnings(as.numeric(as.character(coef(summary(lrfit))[,4])))\n  while((any(probs[-1]>log.regr.pval.cutoff)|any(is.na(probs[-1])))&!is.null(lrfit)){\n    p.way.data.transform = p.way.data.transform[,-(which(colnames(p.way.data.transform[,-1])%in%colnames(p.way.data.transform[,-1])[which(probs[-1]>log.regr.pval.cutoff|is.na(probs[-1]))])+1)]\n    if(is.null(dim(p.way.data.transform))){\n      lrfit = NULL\n    }else{\n      fo = as.formula(paste(\"response ~ \",paste(colnames(p.way.data.transform)[-1],collapse=\" + \")))\n      lrfit = suppressWarnings(speedglm(fo,data=p.way.data.transform,family=binomial(logit),weights=weights))\n      probs = as.numeric(as.character(coef(summary(lrfit))[,4]))\n    }\n  }\n  lrfit\n}\n\n# backward elimination\nfit.model2 = function(type.group.1,\n                      type.group.2,\n                      num.group.1,\n                      num.group.2,\n                      p.way.data.transform,\n                      log.regr.pval.cutoff){\n  response = c(rep(type.group.1,num.group.1),rep(type.group.2,num.group.2))\n  data=cbind(response,data.frame(p.way.data.transform))\n  if(num.group.1>num.group.2){\n    weights = c(rep(num.group.2/num.group.1,num.group.1),rep(1,num.group.2))\n  }else if(num.group.1<num.group.2){\n    weights = c(rep(1,num.group.1),rep(num.group.1/num.group.2,num.group.2))\n  }else{\n    weights = rep(1,num.group.1+num.group.2)\n  }\n  fo = as.formula(paste(\"response ~ \",paste(colnames(data)[-1],collapse=\" + \"),sep=\"\"))\n  lrfit = suppressWarnings(speedglm(fo,data=data,family=binomial(logit),weights=weights))\n  probs = suppressWarnings(as.numeric(as.character(coef(summary(lrfit))[,4])))\n  while(any(probs[-1]>log.regr.pval.cutoff)|any(is.na(probs[-1]))){\n    data = data[,c(1,(which(colnames(data[,-1])%in%colnames(data[,-1])[-which(probs[-1]==sort(probs[-1],decreasing=T)[1]|is.na(probs[-1]))])+1))]\n    fo = as.formula(paste(\"response ~ \",paste(colnames(data)[-1],collapse=\" + \"),sep=\"\"))\n    lrfit = suppressWarnings(speedglm(fo,data=data,family=binomial(logit),weights=weights))\n    probs = as.numeric(as.character(coef(summary(lrfit))[,4]))\n  }\n  lrfit\n}\n\n# forward selection\nfit.model3 = function(type.group.1,\n                      type.group.2,\n                      num.group.1,\n                      num.group.2,\n                      p.way.data.transform,\n                      log.regr.pval.cutoff){\n  response = c(rep(type.group.1,num.group.1),rep(type.group.2,num.group.2))\n  data=cbind(response,data.frame(p.way.data.transform))\n  if(num.group.1>num.group.2){\n    weights = c(rep(num.group.2/num.group.1,num.group.1),rep(1,num.group.2))\n  }else if(num.group.1<num.group.2){\n    weights = c(rep(1,num.group.1),rep(num.group.1/num.group.2,num.group.2))\n  }else{\n    weights = rep(1,num.group.1+num.group.2)\n  }\n  probs = c(1,unlist(lapply(colnames(data)[-1],add.column,\"response\",data,weights)))\n  names(probs) = colnames(data)\n  model.finished = F\n  to.add = \"response\"\n  while(!model.finished){\n    index.cur.to.add = which(names(probs)%in%names(sort(probs[-1])[1])&sort(probs[-1])[1]<=log.regr.pval.cutoff)\n    if(length(index.cur.to.add)==0){\n      model.finished = T\n    }else{\n      cur.to.add = names(probs)[index.cur.to.add]\n      to.add = c(to.add,cur.to.add)\n      data.columns = colnames(data)[-which(colnames(data)%in%to.add[-1])]\n      probs = c(1,unlist(lapply(data.columns[-1],add.column,to.add,data,weights)))\n      names(probs) = data.columns\n    }\n  }\n  if(length(to.add)==1){\n    lrfit = NULL\n  }else{\n    fo = as.formula(paste(\"response ~ \",paste(to.add[-1],collapse=\" + \"),sep=\"\"))\n    lrfit = suppressWarnings(speedglm(fo,data=data[,to.add],family=binomial(logit),weights=weights))\n  }\n  lrfit\n}\n\n# forward selection: adds one predictor variable to the current model and returns the \n# probability of the added variable \nadd.column = function(column,to.add,data,weights){\n  prob=1\n  if(length(to.add[-1])==0){\n    fo = as.formula(paste(\"response ~ \",column,sep=\"\"))\n  }else{\n    fo = as.formula(paste(\"response ~ \",paste(to.add[-1],collapse=\" + \"),\" + \",column,sep=\"\"))\n  }\n  lrfit = suppressWarnings(speedglm(fo,data=data[,c(to.add,column)],family=binomial(logit),weights=weights))\n  if(column%in%rownames(coef(summary(lrfit)))&\n       !is.na(suppressWarnings(as.numeric(as.character(coef(summary(lrfit))[column,4]))))){\n    prob = as.numeric(as.character(coef(summary(lrfit))[column,4]))\n  }\n  prob\n}\n\n# Returns on row per gene for all genes with \nget.gene.data = function(index,snp.sets.per.gene,gwps,SNP.info,min.snps.per.gene,chrs){\n  row = NULL\n  if(!is.null(snp.sets.per.gene[[index]])&\n       length(snp.sets.per.gene[[index]])>=min.snps.per.gene){\n    row = colSums(get.snp.data(snps=snp.sets.per.gene[[index]],\n                               gwps,\n                               chr=chrs[index]))\n  }\n  if(!is.null(row)){\n    row = matrix(row,nrow=1) \n    rownames(row) = index\n  }\n  row/length(snp.sets.per.gene[[index]])\n}\n\n\nget.snp.data = function(snps,gwps,chr){\n  gene.data = NULL\n  coh1.data = NULL\n  coh2.data = NULL\n  cohort1 = gwps@cohort1\n  cohort2 = gwps@cohort2\n  load(cohort1@SNP.infos[grep(paste(\"SNP.infos.\",chr,\".Rdata\",sep=\"\"),cohort1@SNP.infos,fixed=T)])\n  chunks = scores.info[,\"chunk.file\"][which(scores.info[,\"rsid\"]%in%snps)]\n  if(length(chunks)>0){\n    for(chunk in unique(chunks)){\n      load(chunk)\n      part = scores.info[which(scores.info[,\"chunk.file\"]%in%chunk),]\n      coh1.data = rbind(coh1.data,scores[which(part[,\"rsid\"]%in%snps),])\n    }\n  }\n  load(cohort2@SNP.infos[grep(paste(\"SNP.infos.\",chr,\".Rdata\",sep=\"\"),cohort2@SNP.infos,fixed=T)])\n  chunks = scores.info[,\"chunk.file\"][which(scores.info[,\"rsid\"]%in%snps)]\n  if(length(chunks)>0){\n    for(chunk in unique(chunks)){\n      load(chunk)\n      part = scores.info[which(scores.info[,\"chunk.file\"]%in%chunk),]\n      coh2.data = rbind(coh2.data,scores[which(part[,\"rsid\"]%in%snps),])\n    }\n  }\n  cbind(coh1.data,coh2.data)\n}\n\n# Performs fishers method to aquire p-values per gene and performs gene set enrichment analysis as in \ngwps.gsea = function(gwps,p.ways){\n  \n}\n\nadd.genes = function(gwps,p.ways){\n  SNP.info = get.SNP.info(gwps)\n  SNP.info = map.SNPS(p.ways,SNP.info)\n  SNP.info\n}\n\nmap.SNPS = function(p.ways,SNP.info,add.downstream=0,add.upstream=0){\n  entrez.id = p.ways@entrez.id\n  genes.symbols = p.ways@genes.symbols\n  pos.start = p.ways@pos.start\n  pos.end = p.ways@pos.end\n  chromosomes = p.ways@chromosome\n  if(length(which(unique(p.ways@chromosome)%in%unique(SNP.info[,\"chromosome.id\"])))!=length(unique(SNP.info[,\"chromosome.id\"]))){\n    warning(paste(\"Some of the chromosomes in the pathway set were not in the set of chromosomes for the GWAS data: \",\n                  paste(unique(p.ways@chromosome)[-which(unique(p.ways@chromosome)%in%unique(SNP.info[,\"chromosome.id\"]))],collapse=\" \"),sep=\"\"))\n    \n  }\n  if(length(which(unique(SNP.info[,\"chromosome.id\"])%in%unique(p.ways@chromosome)))!=length(unique(p.ways@chromosome))){\n    warning(paste(\"Some of the chromosomes in the GWAS set were not in the set of chromosomes for the pathway data: \",\n                  paste(unique(SNP.info[,\"chromosome.id\"])[-which(unique(SNP.info[,\"chromosome.id\"])%in%unique(p.ways@chromosome))],collapse=\" \"),sep=\"\"))\n  }\n  lapply(1:length(genes.symbols),get.snps.per.gene,\n         pos.start=pos.start,\n         pos.end=pos.end,\n         add.upstream=add.upstream,\n         add.downstream=add.downstream,\n         chromosomes.gs=chromosomes,\n         chromosomes.snps=SNP.info$chromosome.id,\n         positions.snps=SNP.info$position,\n         rsids=SNP.info$rsid)\n}\n\n# Returns the SNPs mapping to a certain gene accesed by the index from the list of genes in the p.ways object.\nget.snps.per.gene = function(index,pos.start,pos.end,add.upstream,\n                             add.downstream,chromosomes.gs,chromosomes.snps,\n                             positions.snps,rsids){\n  snps = rsids[which(chromosomes.snps%in%chromosomes.gs[index]&\n                positions.snps>=(pos.start-add.upstream)[index]&\n                   positions.snps<=(pos.end+add.upstream)[index])]\n  if(length(snps)==0){\n    snps = NULL\n  }\n  snps\n}\n\n# This function produces histograms per file of the proportions of \n# genotype probabilities which do add up to 1. This is done for all \n# SNPs and all individuels.\ngwps.qc = function(gt.files,output.dir,sample.file=NULL,SNPs.remove=NULL,IND.remove=NULL,\n                   chunk.size=1000){\n  samples = NULL\n  if(!is.null(sample.file)&!is.null(SNPs.remove)&!is.null(IND.remove)){\n    samples = read.table(file=sample.file,sep=\" \",stringsAsFactors=F,header=T,skip=1)\n    if(any(file.exists(SNPs.remove))){\n      SNPs.remove = lapply(SNPs.remove,function(file,what,sep,quiet){\n        if(file.exists(file)){\n          scan(file,what=what,sep=sep,quiet=quiet)\n        }else{\n          character()\n        }\n      }\n      ,what=\"character\",sep=\"\\n\",quiet=T)\n    }else{\n      warning(\"The file with SNPs to remove does not exist. \n              A character vector with SNP rs ids is assumed \n              and used to remove SNPs.\")\n    }\n    if(file.exists(IND.remove[1])){\n      IND.remove = scan(file=IND.remove,what=\"character\",sep=\"\\n\",quiet=T)\n    }else{\n      warning(\"The file with Individuals ids to remove does not exist. A \n              character vector with indivividual ids is assumed and used \n              to remove SNPs.\")\n    }\n  }\n  if(is.null(samples)){\n    stop(\"Please provide a .sample file.\")\n  }\n  proportions = lapply(1:length(gt.files),get.prop,gt.files,samples,IND.remove,SNPs.remove,chunk.size)\n  if(!file.exists(output.dir)){\n    dir.create(output.dir,recursive=T)\n  }\n  for(i in 1:length(proportions)){\n    png(paste(output.dir,\"/hist_\",i,\"_\",1,\".png\",sep=\"\"))\n    plot(1:length(proportions[[i]][[1]]),proportions[[i]][[1]],\n         main=paste(\"SNPs from file: \",basename(gt.files[i]),sep=\"\"),\n         ylab=\"SNPs proportion\",xlab=\"SNPs\")\n    dev.off()\n    png(paste(output.dir,\"/hist_\",i,\"_\",2,\".png\",sep=\"\"))\n    plot(1:length(proportions[[i]][[2]]),proportions[[i]][[2]],\n         main=paste(\"Columns from file: \",basename(gt.files[i]),sep=\"\"),\n         ylab=\"Individuals proportion\",xlab=\"Individuals\")\n    dev.off()\n  }\n}\n\nget.prop = function(index,gt.files,samples,IND.remove=NULL,SNPs.remove=NULL,chunk.size=1000){\n  message(paste(\"Processing file: \",gt.files[index],sep=\"\"))\n  finished=F\n  skip=0\n  line.length=0\n  prop.snp.1 = c()\n  prop.ind.1 = NULL\n  GT_calls = NULL\n  while(!finished){\n    message(paste(\"Processing from line \",skip,\" to line \",skip+chunk.size,sep=\"\"))\n    if(skip==0){\n      line.length = length(scan(file=gt.files[index],sep=\" \",what=\"character\",quiet=T,nlines=1))\n    }\n    GT_calls = scan(file=gt.files[index],sep=\" \",what=\"character\",quiet=T,nlines=chunk.size,skip=skip)\n    skip=skip+chunk.size\n    GT_calls = matrix(GT_calls,nrow=length(GT_calls)/line.length,byrow=T)\n    finished = nrow(GT_calls)<chunk.size\n    if(nrow(GT_calls)>0&ncol(GT_calls>0)){\n      if(all(GT_calls[,ncol(GT_calls)]==\"\")){\n        GT_calls = GT_calls[,-ncol(GT_calls)]\n      }\n      rsids = GT_calls[,2]\n      GT_calls = GT_calls[,6:ncol(GT_calls)]\n      rownames(GT_calls) = rsids\n      mode(GT_calls) = \"numeric\"\n      GT_calls = sums.gtcalls(GT_calls)\n      colnames(GT_calls) = samples[,1]\n      if(!is.null(samples)&!is.null(IND.remove)&!is.null(SNPs.remove)){\n        if(length(which(rsids%in%SNPs.remove[[index]]))>0){\n          GT_calls = GT_calls[-which(rsids%in%SNPs.remove[[index]]),]\n        }\n        if(length(which(samples[,1]%in%IND.remove|samples[,2]%in%IND.remove))>0){\n          GT_calls = GT_calls[,-which(samples[,1]%in%IND.remove|samples[,2]%in%IND.remove)]\n        }\n      }\n      if(is.null(prop.ind.1)){\n        prop.ind.1 = rep(0,ncol(GT_calls))\n      }\n      temp.snps = unlist(lapply(1:nrow(GT_calls),row.count.1,GT_calls))\n      names(temp.snps) = rownames(GT_calls) \n      prop.snp.1 = c(prop.snp.1,temp.snps)\n      prop.ind.1 = prop.ind.1+unlist(lapply(1:ncol(GT_calls),col.count.1,GT_calls))\n    }\n  }\n  prop.snp.1 = (prop.snp.1/ncol(GT_calls))\n  prop.ind.1 = (prop.ind.1/length(prop.snp.1))\n  names(prop.ind.1) = colnames(GT_calls)\n  list(snps=prop.snp.1,inds=prop.ind.1)\n}\n\ncol.count.1 = function(index,data){\n  col = data[,index]\n  length(which(col%in%1))\n}\n\nrow.count.1 = function(index,data){\n  row = data[index,]\n  length(which(row%in%1))\n}\n\nsums.gtcalls = function(GT_calls){\n  GT_calls[,seq(from=1,by=3,length.out=(ncol(GT_calls)/3))]+\n    GT_calls[,seq(from=2,by=3,length.out=(ncol(GT_calls)/3))]+\n    GT_calls[,seq(from=3,by=3,length.out=(ncol(GT_calls)/3))]\n}\n\n# Function which produces some statistics of the setup for the current GWPS \ngwps.statistics = function(gwps, p.ways,pvalue.cutoff=0.3,\n                           qq=T,single.chromosomes=T,save.plots=NULL){\n  source(\"/home/christoph/Dropbox/master/workspace/GWPS_R_scripts/manhattan.R\")\n  stats = \"statistics\"\n  if(is.character(save.plots)){\n    if(!file.exists(paste(save.plots,\"/\",stats,sep=\"\"))){\n      dir.create(paste(save.plots,\"/\",stats,sep=\"\"),recursive=T)\n    }\n  }\n#   p.ways = load.pathways(\"/media/christoph/0357FCFC5DF93E00/scores/pathways\")\n#   gwps=load.GWPS(\"/media/christoph/0357FCFC5DF93E00/scores/GWPS\")\n  SNP.info = get.SNP.info(gwps)\n  gene.coverage.all = get.coverage(p.ways,SNP.info,upstream=0,downstream=0)\n  gene.coverage = get.coverage(p.ways,SNP.info[which(SNP.info$p.values<=pvalue.cutoff),],upstream=0,downstream=0)\n  message(paste(\"There are \",nrow(SNP.info),\"SNPs in your dataset.\"))\n  message(paste(\"Of those \",length(gene.coverage.all),\"SNPs are located within genes.\"))\n  message(paste(nrow(SNP.info[which(SNP.info$p.values<=pvalue.cutoff),]),\" SNP p-values are below the threshold of \",pvalue.cutoff))\n  message(paste(\"After applying the p-value threshold \",length(gene.coverage),\" are left to map to genes.\"))\n  message(\"Plots are now generated, please be patient.\")\n  gwps.qq.manhatten(chr=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$chromosome.id,\n                    bp=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$position,\n                    p=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$p.values, \n                    snp=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$rsid,\n                    gene.coverage=gene.coverage,\n                    highlight=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$rsid[which(-log10(SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$p.values)>=50)])\n  invisible(readline(prompt=\"Press [enter] to continue\"))\n  if(is.character(save.plots)){\n    dev.copy(png,paste(save.plots,\"/\",stats,\"/all.chromosomes.png\",sep=\"\"))\n    dev.off()\n  }\n  if(single.chromosomes){\n    for(chromo in unique(SNP.info$chromosome.id)){\n      m=matrix(rep(1,1000),nrow=100,ncol=100,byrow=T)\n      m[1:100,66:100] = 2\n      v = layout(m,respect=T,\n                 width=rep.int(3, ncol(m)),\n                 height=rep.int(1, nrow(m)))\n      indexes = which(SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$chromosome.id%in%chromo)\n      gwps.manhattan(chr=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$chromosome.id[indexes],\n                     bp=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$position[indexes],\n                     p=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$p.values[indexes], \n                     snp=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$rsid[indexes],\n                     gene.coverage=gene.coverage,\n                     highlight=SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$rsid[which(-log10(SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$p.values)>=50)],\n                     main=paste(\"-log p-values for chromosome \",chromo,sep=\"\"))\n      gwps.qq(as.numeric(SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$p.values[indexes]),labels=T,main=paste(\"P-value QQ plot\",chromo))\n      invisible(readline(prompt=\"Press [enter] to continue\"))\n      if(is.character(save.plots)){\n        dev.copy(png,paste(save.plots,\"/\",stats,\"/chromosome.\",chromo,\".png\",sep=\"\"))\n        dev.off()\n      }\n    }\n  }\n  m=matrix(rep(1,1000),nrow=100,ncol=100,byrow=T)\n  v = layout(m,respect=T,\n             width=rep.int(1, ncol(m)),\n             height=rep.int(1, nrow(m)))\n  hist(SNP.info[which(SNP.info$p.values<pvalue.cutoff),]$\n         p.values[-which(SNP.info$rsid%in%gene.coverage.all)],\n       main=\"Distribution of p-values not mapped to genes.\",\n       xlab=\"p-values\")\n  if(is.character(save.plots)){\n    dev.copy(png,paste(save.plots,\"/\",stats,\"/hist.not.covered.png\",sep=\"\"))\n    dev.off()\n  }\n}\n\ngwps.qq.manhatten = function(chr,bp,p,snp,\n                             col=c(\"gray10\", \"gray60\"), ymax=NULL, \n                             suggestiveline=F, genomewideline=F,\n                             highlight=NULL, logp=T,\n                             gene.coverage=NULL,qq=T,...){\n  if(qq){\n    m=matrix(rep(1,1000),nrow=100,ncol=100,byrow=T)\n    m[10:65,60:95] = 2\n    v = layout(m,respect=T,\n               width=rep.int(1.4, ncol(m)),\n               height=rep.int(1, nrow(m)))\n  }\n  gwps.manhattan(chr=chr,bp=bp,p=p,snp=snp,col=col,ymax=ymax,\n                 suggestiveline=suggestiveline,\n                 genomewideline=genomewideline,\n                 highlight=highlight,logp=logp,\n                 gene.coverage=gene.coverage,\n                 ...)\n  #layout.show(v)\n  if(qq){\n    gwps.qq(as.numeric(p),labels=F,main=NULL)\n  }\n}\n\n# get the matrix with all the SNP info needed for the manhattan plot\nget.SNP.info = function(gwps,chr=NULL){\n  ret = NULL\n  files = gwps@cohort1@SNP.infos\n  if(!is.null(chr)){\n    temp= NULL\n    for(pat in chr){\n      temp = c(temp,unique(files[grep(paste(\"SNP.infos.\",pat,sep=\"\"),files,ignore.case=T)]))\n    }\n    files = temp\n  }\n  for(file in files){\n    load(file=file)\n    ret = rbind(ret,scores.info[,c(1,3,7,8)])\n  }  \n  rownames(ret) = NULL\n  ret = data.frame(ret,stringsAsFactors=F)\n  ret$p.values = as.numeric( ret$p.values)\n  ret$position = as.numeric( ret$position)\n  ret\n}\n\n#retrieve the positions for the SNPs in list form\nget.SNP.pos = function(cohort){\n  ret = list()\n  chrs = sub(\".Rdata\",\"\",sub(\"SNP.infos.\",\"\",basename(cohort@SNP.infos),fixed=T),fixed=T)\n  for(file in 1:length(cohort@SNP.infos)){\n    load(cohort@SNP.infos[file])\n    ret[[file]] = list(x=as.numeric(scores.info[,\"position\"]),y=as.numeric(scores.info[,\"p-values\"]))\n  }\n  names(ret) = chrs\n  ret\n}\n\n# returns a list of start and stop positions for all chromosomes \n# where gene coverage is existant.\nget.coverage = function(p.ways,SNP.info,upstream=0,downstream=0){\n  chromosomes = sort(unique(p.ways@chromosome))\n  genes = lapply(chromosomes,get.chr.genes,p.ways)\n  names(genes) = chromosomes\n  ret = unlist(lapply(names(genes),get.covered,genes,SNP.info,upstream,downstream))\n  ret\n}\n\n# returns a character vector of rsids which map to genes on the \n# chormosome in the pathway set suplied.\nget.covered = function(chr,genes,SNP.info,upstream=0,downstream=0){\n  coverage = genes[[chr]]\n  starts = coverage[[1]]-upstream\n  ends = coverage[[2]]+downstream\n  snps = SNP.info[which(SNP.info[,\"chromosome.id\"]%in%chr),]\n  pos = snps[,\"position\"]\n  snps[unique(unlist(lapply(1:length(coverage[[1]]),\n                            function(index,starts,ends,pos){\n                              which(pos>starts[index]&pos<ends[index])\n                            },\n                            starts,ends,pos))),\"rsid\"]\n}\n\n# retrieve gene coverage for a single chromosome\nget.chr.genes = function(chr,p.ways){\n  indexes = which(p.ways@chromosome%in%chr)\n  pos.start = p.ways@pos.start[indexes]\n  pos.end = p.ways@pos.end[indexes]\n  list(pos.start,pos.end)\n}\n\n# Loads a file in gmt format and converts it into the input needed \n# to be used in the add.pathway.list function. Returns null if \n# something was wrong.\nread.pathways.gmt = function(file){\n  ret = NULL\n  if(length(file)==1&is.character(file)&file.exists(file)){\n    file.content = unlist(scan(file=file,what=\"character\",sep=\"\\n\"))\n    sep.content = lapply(strsplit(file.content,\"\\t\"),\n                         function(x){list(name=x[1],description=x[2],genes=x[3:length(x)])})\n    names = unlist(lapply(sep.content,function(x){x[[\"name\"]]}))\n    descriptions = unlist(lapply(sep.content,function(x){x[[\"description\"]]}))\n    genes = lapply(sep.content,function(x){x[[\"genes\"]]})\n    names(genes) = names\n    ret = list(descriptions=descriptions,pathways=genes)\n  }\n  ret\n}\n\n#Creates a pathways object and returns it.\npathways = function(load.pathways=getwd(),access.pathway=c(),names.pathways=c(),\n                    genes.symbols=c(),entrez.id=c(),pos.start=c(),pos.end=c(),\n                    chromosome=c(),description=NULL,database=NULL){\n  setClass(\"pathways\",slots=c(load.pathways=\"character\", # Directory where to store the pathways object for easy reload.\n                              access.pathway=\"character\", # Directory where the pathwayobjects are stored as binary files. \n                              names.pathways=\"character\", # An identifier for the pathway\n                              genes.symbols=\"character\", # Vector containing all gene symbols stored in all pathways.\n                              entrez.id=\"character\", # Vector containing all entrez ids stored in all pathways.\n                              pos.start=\"integer\", # Start position of the genes stored in all pathways\n                              pos.end=\"integer\", # End position of the genes stored in all pathways\n                              chromosome=\"character\", # The chromosome the gene is located on.\n                              description=\"character\", # The pathway descrition, can be NULL.\n                              database=\"character\"), # The database the gene set originates from.\n           prototype=list(load.pathways=load.pathways,access.pathway=c(),names.pathways=c(),\n                          genes.symbols=c(),entrez.id=c(),pos.start=c(),pos.end=c(),\n                          chromosome=c(),description=NULL,database=NULL))\n  pathw = new(\"pathways\")\n  if(!is.null(access.pathway)&is.character(access.pathway)){\n    pathw@access.pathway=access.pathway\n  }\n  if(!is.null(names.pathways)&is.character(names.pathways)){\n    pathw@names.pathways=names.pathways\n  }\n  if(!is.null(genes.symbols)&is.character(genes.symbols)){\n    pathw@genes.symbols=genes.symbols\n  }\n  if(!is.null(entrez.id)&is.character(entrez.id)){\n    pathw@entrez.id=entrez.id\n  }\n  if(!is.null(pos.start)&is.numeric(pos.start)){\n    pathw@pos.start=pos.start\n  }\n  if(!is.null(pos.end)&is.numeric(pos.end)){\n    pathw@pos.end=pos.end\n  }\n  if(!is.null(chromosome)&is.character(chromosome)){\n    pathw@chromosome=chromosome\n  }\n  if(!is.null(description)&is.character(description)){\n    pathw@description=description\n  }\n  if(!is.null(database)&is.character(database)){\n    pathw@database=database\n  }\n  \n  pathw\n}\n\nadd.pathway.list = function(path.ways=NULL, # a pathways object as generated by the pathways function. Note, this object can already contain pathways. Duplicates are not added.\n                            out.dir=NULL, # An directory where to store the pathways as binary files.\n                            pathway.list, # A list with the pathway identifiers as names and vectors with gene symbols or entrez ids as values.\n                            id.type, # The type of ids in pathway.list. Dont input mixed lists. Either \"symbol\" or \"entrez\",\n                            description.list=NULL, # A description for every pathway. Can stay unused\n                            database.list=NULL, # The name of the database the pathway origins from. Can stay unused\n                            output=T, # Whether a message is printed when a new pathway is started to be processed.\n                            save.object=NULL){ # The directory the pathways object is saved under.\n  tryCatch({\n    if(id.type!=\"symbol\"){\n      if(id.type!=\"entrez\"){\n        stop(\"The variable id.type can only be \\\"symbol\\\" for gene symbols or \n             \\\"entrez\\\" for entrez gene ids.\")\n      }\n    }\n    if(is.null(path.ways)){\n      path.ways = pathways()\n    }\n    if(is.null(out.dir)){\n      out.dir = getwd()\n    }else if(!file.exists(out.dir)){\n      dir.create(out.dir)\n    }\n    if(is.null(save.object)){\n      save.object = out.dir\n    }else{\n      save.object = save.object\n    }\n    if(length(description.list)<length(pathway.list)&length(description.list)>1){\n      stop(\"Not enough descriptions for number of pathways. For every pathway \n           there should be a description or one description for all or none at all.\")\n    }\n    if(length(database.list)<length(pathway.list)&length(database.list)>1){\n      stop(\"Not enough databases for number of pathways. For every pathway \n           there should be a database or one database for all or none at all.\")\n    }\n    if(length(description.list)==1){\n      description.list = rep(description.list,length.out=length(pathway.list))\n    }\n    if(length(database.list)==1){\n      database.list = rep(database.list,length.out=length(pathway.list))\n    }\n    if(is.null(description.list)){\n      description.list = rep(\"\",length.out=length(pathway.list))\n    }\n    if(is.null(database.list)){\n      database.list = rep(\"\",length.out=length(pathway.list))\n    }\n    for(index in 1:length(pathway.list)){\n      if(output){\n        cat(\"Processing pathway \",names(pathway.list)[index],\".\\n\")\n      }\n      p.name = names(pathway.list)[index]\n      if(any(path.ways@names.pathways%in%p.name)&output){\n        cat(paste(\"Pathway identifier: \",p.name,\" already exists in pathways object. \n                      Latest entry is ignored.\\n\",sep=\"\"))\n      }else{\n        p.path = paste(out.dir,\"/\",p.name,\".RDS\",sep=\"\")\n        genes = pathway.list[[index]]\n        store = list(name=p.name,genes=genes)\n        genes.to.add = c()\n        if(id.type==\"entrez\"){\n          indexes = which(pathway.list[[index]]%in%path.ways@entrez.id) \n        }else if(id.type==\"symbol\"){\n          indexes = which(pathway.list[[index]]%in%path.ways@genes.symbols) \n        }else{\n          stop(\"Only two id types are supported. Choose either entrez or symbol.\")\n        }\n        if(length(indexes)>0){\n          genes.to.add = pathway.list[[index]][-indexes]\n        }else{\n          genes.to.add = pathway.list[[index]]\n        }\n        if(length(genes.to.add)>0){\n          new.genes = get.gene.info(genes.to.add,id.type)\n          if(nrow(new.genes)<length(genes.to.add)&output){\n            cat(\"Warning: There where genes where no informations could be obtained\\n\")\n          }\n          if(nrow(new.genes)>0){\n            path.ways@genes.symbols = c(path.ways@genes.symbols,new.genes[,1])\n            path.ways@entrez.id = c(path.ways@entrez.id,as.character(new.genes[,2]))\n            path.ways@pos.start = c(path.ways@pos.start,new.genes[,4])\n            path.ways@pos.end = c(path.ways@pos.end,new.genes[,5])\n            path.ways@chromosome = c(path.ways@chromosome,new.genes[,3])\n          }\n        }\n        saveRDS(store,file=p.path)\n        path.ways@load.pathways = save.object\n        path.ways@names.pathways = c(path.ways@names.pathways,p.name)\n        path.ways@access.pathway = c(path.ways@access.pathway,p.path)\n        path.ways@description = c(path.ways@description,description.list[index])\n        path.ways@database = c(path.ways@database,database.list[index])\n      }\n      saveRDS(path.ways,file=paste(save.object,\"/\",\"pathways.RDS\",sep=\"\"))\n    }\n    return(path.ways)\n  }, error = function(e) print(e), finally=return(path.ways))\n}\n\nload.pathways = function(directory){\n  setClass(\"pathways\",slots=c(load.pathways=\"character\", # Directory where to store the pathways object for easy reload.\n                              access.pathway=\"character\", # Directory where the pathwayobjects are stored as binary files. \n                              names.pathways=\"character\", # An identifier for the pathway\n                              genes.symbols=\"character\", # Vector containing all gene symbols stored in all pathways.\n                              entrez.id=\"character\", # Vector containing all entrez ids stored in all pathways.\n                              pos.start=\"integer\", # Start position of the genes stored in all pathways\n                              pos.end=\"integer\", # End position of the genes stored in all pathways\n                              chromosome=\"character\", # The chromosome the gene is located on.\n                              description=\"character\", # The pathway descrition, can be NULL.\n                              database=\"character\"), # The database the gene set originates from.\n           prototype=list(load.pathways=\"\",access.pathway=c(),names.pathways=c(),\n                          genes.symbols=c(),entrez.id=c(),pos.start=c(),pos.end=c(),\n                          chromosome=c(),description=NULL,database=NULL))\n  readRDS(file=paste(directory,\"/\",\"pathways.RDS\",sep=\"\"))\n}\n\n# input = read.pathways.gmt(\"/media/christoph/0357FCFC5DF93E00/msigdb/msigdb.v4.0.symbols.part2.gmt\")\n# p.ways = add.pathway.list(out.dir=\"/media/christoph/0357FCFC5DF93E00/test/pathways/pathways\",\n#                             pathway.list=input$pathways,\n#                             id.type=\"symbol\",\n#                             description.list=input$descriptions,\n#                             database.list=\"msigdb\",\n#                             output=T,\n#                             save.object=\"/media/christoph/0357FCFC5DF93E00/test/pathways\")\n\n# Get chromosome and start and end position of a gene.\n# This function uses the biomaRt library as the \n# Homo.sapiens package delivers slightly different \n# results in terms of start and end positions of genes. \nget.gene.info = function(input.ids,input.type){\n  input.ids = na.omit(input.ids)\n  if(length(which(input.ids%in%\"\"))>0){\n    input.ids = input.ids[-which(input.ids%in%\"\")]\n  }\n  ensembl = useMart(\"ensembl\",dataset=\"hsapiens_gene_ensembl\")\n  attributes = listAttributes(ensembl)\n  filters = listFilters(ensembl)\n  ret=NULL\n  if(input.type==\"entrez\"){\n    ret = getBM(attributes=attributes[c(57,50,6,7,8),1],filters=filters[127,1],values=input.ids,ensembl)\n  }else if(input.type==\"symbol\"){\n    ret = getBM(attributes=attributes[c(57,50,6,7,8),1],filters=filters[110,1],values=input.ids,ensembl)\n  }else{\n    stop(\"Only entrez (entrez) ids or official gene symbols (symbol) are allowed as input.type.\")\n  }\n  if(length(which(nchar(ret[,3])>2))>0){\n    ret = ret[-which(nchar(ret[,3])>2),]\n  }\n  if(length(which(nchar(ret[,3])==1))>0){\n    ret[which(nchar(ret[,3])==1),3] = paste(\"0\",ret[which(nchar(ret[,3])==1),3],sep=\"\")\n  }\n  ret\n}\n\n# Takes a list of SNPs and queries NCBI for informations on that SNP\nmap.SNPs.to.genes = function(SNPs){\n  result1=GetSNPInfo(unique(SNPs),pbar=F) # map SNPs to genes\n  result1[which(nchar(result1[,\"chr\"])==1),\"chr\"] = \n    paste(\"0\", result1[which(nchar(result1[,\"chr\"])==1),\"chr\"],sep=\"\")\n  result2 = select(Homo.sapiens, keys=unlist(strsplit(result1[,\"locusID\"],\",\")), columns=\"PATH\", keytype=\"ENTREZID\") # convert entrez ids to pathway gene ids\n  result2 = result2[which(!is.na(result2[,2])),] # remove NA values\n  merge(result1,result2,by.x=\"locusID\",by.y=\"ENTREZID\") # merge result one and two \n}\n\n# just converts a list containing vectors of genes into a matrix format.\nconvert.to.frame = function(pathways,ref.pathways){\n  res = NULL\n  for(pathway in names(pathways)){\n    res = rbind(res,cbind(pathway,pathways[[pathway]],ref.pathways[paste(\"path:hsa\",pathway,sep=\"\")]))\n  }\n  colnames(res)=c(\"KEGG_PATHWAY\",\"ENTREZID\",\"DESCRIPTION\")\n  res\n}\n\n#load genotypes for chromosome\nread.gt.file = function(file){\n  if(file.info(file)$size!=0){\n    GT_calls = read.table(file,sep=\" \",stringsAsFactors=F)\n  }else{\n    stop(paste(\"File \",file,\" is empty.\",sep=\"\"))\n  }\n  GT_calls[,-which(apply(GT_calls,2,function(x){all(is.na(x))}))]\n}\n\n#converts genotypes such as A/C or AC into IUPAC format to save memory.\nConvertIUPAC = function(x){\n  tab = IUPAC()\n  x[which(toupper(x)%in%\"A\")] = tab[1,1]\n  x[which(toupper(x)%in%\"AA\")] = tab[1,1]\n  x[which(toupper(x)%in%\"A/A\")] = tab[1,1]\n  x[which(toupper(x)%in%\"C\")] = tab[2,1]\n  x[which(toupper(x)%in%\"CC\")] = tab[2,1]\n  x[which(toupper(x)%in%\"C/C\")] = tab[2,1]\n  x[which(toupper(x)%in%\"G\")] = tab[3,1]\n  x[which(toupper(x)%in%\"GG\")] = tab[3,1]\n  x[which(toupper(x)%in%\"G/G\")] = tab[3,1]\n  x[which(toupper(x)%in%\"T\")] = tab[4,1]\n  x[which(toupper(x)%in%\"TT\")] = tab[4,1]\n  x[which(toupper(x)%in%\"T/T\")] = tab[4,1]\n  x[which(toupper(x)%in%\"AC\")] = tab[5,1]\n  x[which(toupper(x)%in%\"CA\")] = tab[5,1]\n  x[which(toupper(x)%in%\"A/C\")] = tab[5,1]\n  x[which(toupper(x)%in%\"C/A\")] = tab[5,1]\n  x[which(toupper(x)%in%\"AG\")] = tab[6,1]\n  x[which(toupper(x)%in%\"GA\")] = tab[6,1]\n  x[which(toupper(x)%in%\"A/G\")] = tab[6,1]\n  x[which(toupper(x)%in%\"G/A\")] = tab[6,1]\n  x[which(toupper(x)%in%\"AT\")] = tab[7,1]\n  x[which(toupper(x)%in%\"TA\")] = tab[7,1]\n  x[which(toupper(x)%in%\"A/T\")] = tab[7,1]\n  x[which(toupper(x)%in%\"T/A\")] = tab[7,1]\n  x[which(toupper(x)%in%\"CG\")] = tab[8,1]\n  x[which(toupper(x)%in%\"GC\")] = tab[8,1]\n  x[which(toupper(x)%in%\"C/G\")] = tab[8,1]\n  x[which(toupper(x)%in%\"G/C\")] = tab[8,1]\n  x[which(toupper(x)%in%\"CT\")] = tab[9,1]\n  x[which(toupper(x)%in%\"TC\")] = tab[9,1]\n  x[which(toupper(x)%in%\"C/T\")] = tab[9,1]\n  x[which(toupper(x)%in%\"T/C\")] = tab[9,1]\n  x[which(toupper(x)%in%\"GT\")] = tab[10,1]\n  x[which(toupper(x)%in%\"TG\")] = tab[10,1]\n  x[which(toupper(x)%in%\"G/T\")] = tab[10,1]\n  x[which(toupper(x)%in%\"T/G\")] = tab[10,1]\n  x[which(toupper(x)%in%\"ACG\")] = tab[11,1]\n  x[which(toupper(x)%in%\"CAG\")] = tab[11,1]\n  x[which(toupper(x)%in%\"CGA\")] = tab[11,1]\n  x[which(toupper(x)%in%\"GCA\")] = tab[11,1]\n  x[which(toupper(x)%in%\"GAC\")] = tab[11,1]\n  x[which(toupper(x)%in%\"AGC\")] = tab[11,1]\n  x[which(toupper(x)%in%\"A/C/G\")] = tab[11,1]\n  x[which(toupper(x)%in%\"C/A/G\")] = tab[11,1]\n  x[which(toupper(x)%in%\"C/G/A\")] = tab[11,1]\n  x[which(toupper(x)%in%\"G/C/A\")] = tab[11,1]\n  x[which(toupper(x)%in%\"G/A/C\")] = tab[11,1]\n  x[which(toupper(x)%in%\"A/G/C\")] = tab[11,1]\n  x[which(toupper(x)%in%\"ACT\")] = tab[12,1]\n  x[which(toupper(x)%in%\"CAT\")] = tab[12,1]\n  x[which(toupper(x)%in%\"CTA\")] = tab[12,1]\n  x[which(toupper(x)%in%\"TCA\")] = tab[12,1]\n  x[which(toupper(x)%in%\"TAC\")] = tab[12,1]\n  x[which(toupper(x)%in%\"ATC\")] = tab[12,1]\n  x[which(toupper(x)%in%\"A/C/T\")] = tab[12,1]\n  x[which(toupper(x)%in%\"C/A/T\")] = tab[12,1]\n  x[which(toupper(x)%in%\"C/T/A\")] = tab[12,1]\n  x[which(toupper(x)%in%\"T/C/A\")] = tab[12,1]\n  x[which(toupper(x)%in%\"T/A/C\")] = tab[12,1]\n  x[which(toupper(x)%in%\"A/T/C\")] = tab[12,1]\n  x[which(toupper(x)%in%\"AGT\")] = tab[13,1]\n  x[which(toupper(x)%in%\"GAT\")] = tab[13,1]\n  x[which(toupper(x)%in%\"GTA\")] = tab[13,1]\n  x[which(toupper(x)%in%\"TGA\")] = tab[13,1]\n  x[which(toupper(x)%in%\"TAG\")] = tab[13,1]\n  x[which(toupper(x)%in%\"ATG\")] = tab[13,1]\n  x[which(toupper(x)%in%\"A/G/T\")] = tab[13,1]\n  x[which(toupper(x)%in%\"G/A/T\")] = tab[13,1]\n  x[which(toupper(x)%in%\"G/T/A\")] = tab[13,1]\n  x[which(toupper(x)%in%\"T/G/A\")] = tab[13,1]\n  x[which(toupper(x)%in%\"T/A/G\")] = tab[13,1]\n  x[which(toupper(x)%in%\"A/T/G\")] = tab[13,1]\n  x[which(toupper(x)%in%\"CGT\")] = tab[14,1]\n  x[which(toupper(x)%in%\"GCT\")] = tab[14,1]\n  x[which(toupper(x)%in%\"GTC\")] = tab[14,1]\n  x[which(toupper(x)%in%\"TGC\")] = tab[14,1]\n  x[which(toupper(x)%in%\"TCG\")] = tab[14,1]\n  x[which(toupper(x)%in%\"CTG\")] = tab[14,1]\n  x[which(toupper(x)%in%\"C/G/T\")] = tab[14,1]\n  x[which(toupper(x)%in%\"G/C/T\")] = tab[14,1]\n  x[which(toupper(x)%in%\"G/T/C\")] = tab[14,1]\n  x[which(toupper(x)%in%\"T/G/C\")] = tab[14,1]\n  x[which(toupper(x)%in%\"T/C/G\")] = tab[14,1]\n  x[which(toupper(x)%in%\"C/T/G\")] = tab[14,1]\n  x[which(toupper(x)%in%\"ACGT\")] = tab[15,1]\n  x[which(toupper(x)%in%\"CAGT\")] = tab[15,1]\n  x[which(toupper(x)%in%\"CGAT\")] = tab[15,1]\n  x[which(toupper(x)%in%\"CGTA\")] = tab[15,1]\n  x[which(toupper(x)%in%\"GCTA\")] = tab[15,1]\n  x[which(toupper(x)%in%\"GTCA\")] = tab[15,1]\n  x[which(toupper(x)%in%\"GTAC\")] = tab[15,1]\n  x[which(toupper(x)%in%\"TGAC\")] = tab[15,1]\n  x[which(toupper(x)%in%\"TAGC\")] = tab[15,1]\n  x[which(toupper(x)%in%\"TACG\")] = tab[15,1]\n  x[which(toupper(x)%in%\"ATCG\")] = tab[15,1]\n  x[which(toupper(x)%in%\"ACTG\")] = tab[15,1]\n  x[which(toupper(x)%in%\"A/C/G/T\")] = tab[15,1]\n  x[which(toupper(x)%in%\"C/A/G/T\")] = tab[15,1]\n  x[which(toupper(x)%in%\"C/G//AT\")] = tab[15,1]\n  x[which(toupper(x)%in%\"C/G/T/A\")] = tab[15,1]\n  x[which(toupper(x)%in%\"G/C/T/A\")] = tab[15,1]\n  x[which(toupper(x)%in%\"G/T/C/A\")] = tab[15,1]\n  x[which(toupper(x)%in%\"G/T/A/C\")] = tab[15,1]\n  x[which(toupper(x)%in%\"T/G/A/C\")] = tab[15,1]\n  x[which(toupper(x)%in%\"T/A/G/C\")] = tab[15,1]\n  x[which(toupper(x)%in%\"T/A/C/G\")] = tab[15,1]\n  x[which(toupper(x)%in%\"A/T/C/G\")] = tab[15,1]\n  x[which(toupper(x)%in%\"A/C/T/G\")] = tab[15,1]\n  tester = which(x%in%tab[1,1]|x%in%tab[2,1]|x%in%tab[3,1]|x%in%tab[4,1]|\n                   x%in%tab[5,1]|x%in%tab[6,1]|x%in%tab[7,1]|x%in%tab[8,1]|\n                   x%in%tab[9,1]|x%in%tab[10,1]|x%in%tab[11,1]|x%in%tab[12,1]|\n                   x%in%tab[13,1]|x%in%tab[14,1]|x%in%tab[15,1]|x%in%\"X\")\n  if(length(x[-tester])>0){\n    warning(\"Some input could not be converted\")\n  }\n  x\n}\n\n#converts a vector with geneotypes in genotype format into nucleotide \n#genotypes such as \\\"A/C\\ or IUPAC\". \nprocess_calls = function(x,threshold=1,chromosome.id=\"\"){\n  if(chromosome.id==\"\"){\n    chromosome.id=NA\n  }\n  start = unlist(c(x[2],x[1],x[3],x[4],x[5],chromosome.id))\n  gts=c()\n  count = 1\n  for(i in seq(from=6,to=length(x),by=3)){\n    if(sum(x[i:(i+2)])<threshold){\n      gts = c(gts,\"X\")# to be swapped by NAs\n    }else if(x[i]==max(x[i:(i+2)])&x[i]>threshold){\n      #first homocygote first allele\n      gts = c(gts,paste(x[4],x[4],sep=\"/\"))\n    }else if(x[i+1]==max(x[i:(i+2)])&x[i+1]>threshold){\n      #second heterocygotes\n      gts = c(gts,paste(x[4:5],collapse=\"/\"))\n    }else if(x[i+2]==max(x[i:(i+2)])&x[i+2]>threshold){\n      #third homocygote second allele\n      gts = c(gts,paste(x[5],x[5],sep=\"/\"))\n    }else{\n      gts = c(gts,\"X\")# to be swapped by NAs\n    }\n  }\n  gts = unlist(gts)\n  names(gts) = NULL\n  gts[which(gts%in%\"X\")]=NA\n  c(start,gts)\n}\n\n#Takes a SNPTEST output file and retrieves the rsid of the SNP, the p-value \n#for the SNP and which allele is asociated with the disease by calculating \n#the odds ratio of which allele is the Risk allele.\nclean.SNPTEST = function(to.clean=NULL,store=\"\",to.remove=NULL,comment.not.na.remove=T){\n  if(is.character(to.clean)){\n    if(file.info(to.clean)$size!=0){\n      to.clean = read.table(to.clean,sep=\" \",stringsAsFactors=F,header=T)\n    }else{\n      stop(paste(\"File \",to.clean,\" is empty.\",sep=\"\"))\n    }\n  }else if(is.null(to.clean)|class(to.clean)!=\"data.frame\"){\n    stop(\"Please provide the \\\"to.clean\\\" variable. This can be a character \n         string containing the directory path to a file or the data.frame \n         containing the contents of the file.\")\n  }\n  ret=NULL\n  pvalue.index = grep(\"pvalue\",colnames(to.clean),fixed=T)\n  pvalues = to.clean[,pvalue.index]\n  pvalues[which(is.na(pvalues))] = 1\n  pvalues[which(pvalues==0)] = 1*10^-323\n  rsids = to.clean[,\"rsid\"]\n  # returns the risk alleles in integer format (1,2,3,4 = A,C,G,T)\n  riskalleles = unlist(lapply(1:nrow(to.clean),get.risk.allele,as.matrix(to.clean)))\n  remove = which(is.na(riskalleles))\n  remove = unique(c(remove,which(is.na(pvalues))))\n  if(!is.null(to.remove)){\n    if(file.exists(to.remove[1])){\n      to.remove = scan(to.remove[1],what=\"character\",\n                                   quiet=T,sep=\"\\n\")\n    }\n    remove = unique(c(remove,which(rsids%in%to.remove)))\n  }\n  if(!is.character(comment.not.na.remove)){\n    if(comment.not.na.remove){ # Comments not NA in SNPTEST output file normally mean something was wrong, therefore remove them.\n      remove = unique(c(remove,which(!is.na(to.clean[,\"comment\"]))))\n    }\n  }else{\n    remove = unique(c(remove,which(to.clean[,\"comment\"]%in%comment.not.na.remove)))\n  }\n  if(length(remove)>0){\n    ret = cbind(pvalues[-remove],riskalleles[-remove]) \n    rownames(ret) = rsids[-remove]\n  }else{\n    ret = cbind(pvalues,riskalleles) \n    rownames(ret) = rsids\n  }\n  colnames(ret) = c(\"pvalue\",\"RiskAllele\")\n  if(store!=\"\"&is.character(store)){\n    save(ret,file=store)\n  }\n  ret\n}\n\nget.risk.allele = function(index,to.clean){\n  row = to.clean[index,]\n  ret = c(\"A\",\"C\",\"G\",\"T\")\n  or = (2*as.numeric(row[\"controls_BB\"])+as.numeric(row[\"controls_AB\"])+0.5)*\n    (2*as.numeric(row[\"cases_AA\"])+as.numeric(row[\"cases_AB\"])+0.5)/\n    ((2*as.numeric(row[\"controls_AA\"])+as.numeric(row[\"controls_AB\"])+0.5)*\n       (2*as.numeric(row[\"cases_BB\"])+as.numeric(row[\"cases_AB\"])+0.5))\n  if(!is.na(or)){\n    alleleA = row[\"alleleA\"]\n    alleleB = row[\"alleleB\"]\n    RiskAllele = alleleA\n    if(or<1){\n      RiskAllele = alleleB\n    }\n    which(ret==RiskAllele)\n  }else{\n    NA\n  }\n}\n\nget.ids = function(GT_calls){\n  unlist(lapply(GT_calls,function(x){strsplit(x,\" \")[[1]][2]}))\n}\n\n# Returns a row of converted gentype calls.\n# homozygote for risk allele = 2*-log(p-value)\n# heterozygote = 1*-log(p-value)\n# otherwise 0 \ncall.scores = function(index,GT_calls, SNPTEST.clean,threshold){\n  row.gts = GT_calls[index,]\n  rsid = row.gts[2]\n  triplets = as.numeric(row.gts[6:length(row.gts)])\n  ind1 = seq(from=1,by=3,to=length(triplets))\n  ind2 = seq(from=2,by=3,to=length(triplets))\n  ind3 = seq(from=3,by=3,to=length(triplets))\n  scores = scores = rep(0,(length(triplets)/3))\n  if(length(which(rownames(SNPTEST.clean)%in%rsid))>0){\n    row.clean = SNPTEST.clean[which(rownames(SNPTEST.clean)%in%row.gts[2]),] \n    scores[which(triplets[ind1]>=threshold)] = 2\n    scores[which(triplets[ind2]>=threshold)] = 1\n    scores[which(triplets[ind3]>=threshold)] = 3\n    alleles = row.gts[4:5]\n    risk = c(\"A\",\"C\",\"G\",\"T\")[row.clean[2]]\n    p=row.clean[1]\n    if(risk==alleles[2]){\n      scores[which(scores%in%2)] = 0\n      scores[which(scores%in%3)] = 2\n    }else{\n      scores[which(scores%in%2)] = 2\n      scores[which(scores==3)] = 0\n    }\n    scores = scores*(-log(p))\n    scores = c(row.clean[1],row.clean[2],scores)\n    names(scores) = NULL\n  }else{\n    warning(paste(\"rsid: \",rsid,\" was not in SNPTEST output. A row of zeros was returned for this SNP.\",sep=\"\"))\n  }\n  scores\n}\n\nget.score = function(index,alleles,row.clean,threshold){\n  #print(ind)\n  risk = c(\"A\",\"C\",\"G\",\"T\")[row.clean[2]]\n  p=row.clean[1]\n  score.ret(risk,p,index,alleles)\n}\n\nscore.ret = function(risk,p,index,alleles){\n  if(is.na(index)){\n    NA\n  }else if(index==1&risk==alleles[2]){\n    0\n  }else if(index==3&risk==alleles[1]){\n    0\n  }else if(index==1&risk==alleles[1]){\n    (log(p)*-2)\n  }else if(index==3&risk==alleles[2]){\n    (log(p)*-2)\n  }else{\n    (log(p)*-1)\n  }\n}\n\n#Calculates the scores fore each SNP according to the function -log(p)*m. Where p is the \n#pvalue for the SNP and m (0,1 or 2) is whether the SNP is homozygote for the variant \n#allele, heterozygote, or homozygote for the risk allele. \nget.scores = function(GT_calls=NULL,threshold=1,map=NULL,ind.remove=NULL,\n                      SNPTEST.clean=NULL,chromosome.id=\"\",output=F,\n                      chunk.size,output.dir){\n  file=GT_calls\n  if(chromosome.id==\"\"){\n    chromosome.id=NA\n  }\n  if(is.character(SNPTEST.clean)){\n    SNPTEST.clean = load(file=SNPTEST.clean)\n  }else if(class(SNPTEST.clean)!=\"matrix\"|is.null(SNPTEST.clean)){\n    stop(\"Please provide the \\\"SNPTEST.clean\\\" value. A character string pointing to the \n         directory location or a data.frame object containing the SNPTEST output.\")\n  }\n  SNP.infos = NULL\n  ret = list()\n  finished=F\n  nlines = chunk.size\n  skip = 0\n  line.length = 0\n  count = 1\n  #total.scores = NULL\n  risk.alleles = c()\n  pvalues = c()\n  while(!finished){\n    if(skip==0){\n      line.length = length(scan(file=file,sep=\" \",what=\"character\",quiet=T,nlines=1))\n    }\n    GT_calls = scan(file=file,sep=\" \",what=\"character\",quiet=T,nlines=chunk.size,skip=skip)\n    skip=skip+chunk.size\n    GT_calls = matrix(GT_calls,nrow=length(GT_calls)/line.length,byrow=T)\n    if(output){\n      cat(\"Read in chunk \",count, \" with \",nrow(GT_calls), \" lines.\\n\")\n    }\n    finished = nrow(GT_calls)<chunk.size\n    if(all(GT_calls[,ncol(GT_calls)]==\"\")){\n      GT_calls = GT_calls[,-ncol(GT_calls)]\n    }\n    rsids = GT_calls[,2]\n    if(length(which(duplicated(rsids)))>0){\n      GT_calls = GT_calls[-which(duplicated(rsids)),]\n      rsids = rsids[-which(duplicated(rsids))]\n    }\n    if(length(which(duplicated(rownames(SNPTEST.clean))))>0){\n      SNPTEST.clean = SNPTEST.clean[-which(duplicated(rownames(SNPTEST.clean))),]\n    }\n    indexes = which(rsids%in%rownames(SNPTEST.clean))\n    GT_calls = GT_calls[indexes,]\n    rsids = rsids[indexes]\n    if(nrow(GT_calls)>0){\n      scores = do.call(rbind,lapply(1:nrow(GT_calls), call.scores,\n                                    GT_calls=GT_calls,\n                                    SNPTEST.clean=SNPTEST.clean,\n                                    threshold=threshold))\n      rownames(scores) = rownames(rsids)\n      pvalues = c(pvalues,scores[,1])\n      risk.alleles = c(risk.alleles,c(\"A\",\"C\",\"G\",\"T\")[scores[,2]])\n      scores = scores[,-(1:2)]\n      if(length(ind.remove)>0){\n        scores = scores[,-(ind.remove)]\n      }\n      if(!file.exists(paste(output.dir,\"/scores\",sep=\"\"))){\n        dir.create(paste(output.dir,\"/scores\",sep=\"\"))\n      }\n      save(scores,file=paste(output.dir,\"/scores/chr\",chromosome.id,\"_chunk_\",count,\n                             \".Rdata\",sep=\"\"))\n      temp = cbind(GT_calls[,1:5],rep(paste(output.dir,\"/scores/chr\",chromosome.id,\n                                            \"_chunk_\",count,\".Rdata\",sep=\"\"\n                                            ),nrow(GT_calls)))\n      count=count+1\n      SNP.infos = rbind(SNP.infos,temp)\n    }\n  }\n  SNP.infos = SNP.infos[,c(2,1,3,4,5,6)]\n  SNP.infos = cbind(SNP.infos,rep(chromosome.id,nrow(SNP.infos)),pvalues,risk.alleles)\n  colnames(SNP.infos) = c(\"rsid\",\"SNP.id2\",\"position\",\"allele1\",\"allele2\",\n                          \"chunk.file\",\"chromosome.id\",\"p-values\",\"risk.alleles\")\n  SNP.infos\n}\n\n#This function enables to convert a whole cohort\nget.cohort = function(GT_calls=NULL,threshold=1,map=NULL,ind.remove=NULL,\n                      SNPTEST.clean=NULL,chromosome.id=\"\",output=F,\n                      type,output.dir=\"\",name=\"\",chunk.size=5000,run.again=NULL,\n                      comment.not.na.remove=T,snp.removed.check=NULL){\n  setClass(\"cohort\", \n           slots=c(name=\"character\",type=\"character\",map=\"data.frame\",\n                   output.dir=\"character\",SNP.infos=\"character\"),\n           prototype=c(name=\"\",type=\"\",map=data.frame(),output.dir=\"\",\n                       SNP.infos=c()))\n  if(is.null(run.again)){\n    coh = new(\"cohort\")\n  }else if(class(run.again)[1]==\"cohort\"){\n    coh = run.again\n  }\n  if(!is.numeric(threshold)|threshold<0|threshold>1){\n    stop(\"Please provide a number between 0 and 1 for the \\\"threshold\\\" argument.\")\n  }\n  if(type!=\"case\"&type!=\"control\"){\n    stop(\"Please specify whether the cohort is a case (case) or control (control) cohort\")\n  }else{\n    coh@type=type\n  }\n  if(name==\"\"){\n    warning(\"It is strongly recomended to provide a name for the cohort.\")\n  }else{\n    coh@name=name\n  }\n  if(length(output.dir)!=1){\n    stop(\"Please provide a valid output directory for the score files.\")\n  }else if(!file.exists(output.dir)){\n    dir.create(output.dir)\n  }\n  coh@output.dir=coh@output.dir\n  if(is.null(map)){\n    if(!is.null(run.again)){\n      if(dim(run.again@map)[1]!=0&dim(run.again@map)[2]!=0){\n        map=run.again@map\n      }else{\n        stop(\"Please provide the map variable. This can be a data frame from a \\\".sample\\\" file \n         or a character string with a path pointing to the rightsample file.\")\n      }\n    }else{\n      stop(\"Please provide the map variable. This can be a data frame from a \\\".sample\\\" file \n         or a character string with a path pointing to the rightsample file.\")\n    }\n  }else if(is.character(map)){\n    if(file.info(map)$size!=0){\n      map = read.table(map,sep=\" \",stringsAsFactors=F,header=T)\n      header.values = colnames(map)\n      colnames(map) = NULL\n      map = data.frame(t(map[-1,]),stringsAsFactors=F)\n      rownames(map) = header.values\n    }else{\n      stop(paste(\"File \",map,\" is empty.\",sep=\"\"))\n    }\n  }else if(class(map)!=\"data.frame\"){\n    stop(\"Wrong argument for variable map. Only a data.frame or a character string are valid. \n         The string should be a directory path to the \\\".sample\\\" file and the data.frame \n       should be the contents of this \\\".sample\\\" file.\")\n  }\n  indexes.remove = c()\n  if(!is.null(ind.remove)&length(ind.remove)!=0){\n    for(i in 1:length(header.values)){\n      if(any(as.character(unlist(map[i,]))%in%ind.remove)){\n        indexes.remove = c(indexes.remove,which(as.character(unlist(map[i,]))%in%ind.remove))\n      }\n    }\n    if(length(indexes.remove)>0){\n      indexes.remove = sort(unique(indexes.remove))\n      map=map[,-indexes.remove]\n    }\n  }\n  coh@map=map\n  ind.remove = indexes.remove\n#   scores=NULL\n  if(length(GT_calls)==length(SNPTEST.clean)&\n       is.character(GT_calls)&is.character(SNPTEST.clean)){\n    for(f in 1:length(GT_calls)){\n      if(file.info(GT_calls[f])$size==0){\n        warning(paste(\"File \",GT_calls[f],\" was empty. This input was ignored.\",sep=\"\"))\n        next()\n      }\n      if(file.info(SNPTEST.clean[f])$size==0){\n        warning(paste(\"File \",SNPTEST.clean[f],\" was empty. This input was ignored.\",sep=\"\"))\n        next()\n      }\n      if(output){\n        cat(\"Start File: \",GT_calls[f],\"\\n\")  \n      }\n      if(!is.null(run.again)&file.exists(\n        paste(output.dir,\"/SNP_infos/\",\"SNP.infos.\",chromosome.id[f],\".Rdata\",sep=\"\"))){\n        warning(\"The variable \\\"run.again\\\" was not null and output for the specified \n                files already exists.\")\n        next()\n      }\n      if(file.exists(GT_calls[f])&file.exists(SNPTEST.clean[f])){\n        if(length(chromosome.id)==length(GT_calls)){\n          scores.info = get.scores(GT_calls=GT_calls[f],\n                                  threshold=threshold,\n                                  map=map,\n                                  ind.remove=ind.remove,\n                                  SNPTEST.clean=clean.SNPTEST(to.clean=SNPTEST.clean[f],\n                                                              comment.not.na.remove=comment.not.na.remove,\n                                                              to.remove=snp.removed.check[f]),#look at speed for this\n                                  chromosome.id=chromosome.id[f],\n                                  output=output,\n                                  chunk.size=chunk.size,\n                                  output.dir=output.dir)\n        }else{\n          scores.info = get.scores(GT_calls[f],\n                                  threshold=threshold,\n                                  map=map,\n                                  ind.remove,\n                                  SNPTEST.clean=clean.SNPTEST(to.clean=SNPTEST.clean[f],\n                                                              comment.not.na.remove=comment.not.na.remove,\n                                                              to.remove=snp.removed.check[f]),#look at speed for this\n                                  output=output,\n                                  chunk.size=chunk.size,\n                                  output.dir=output.dir)\n        }\n        files.SNP.infos = c()\n        if(!file.exists(paste(output.dir,\"SNP_infos\",sep=\"/\"))){\n          dir.create(paste(output.dir,\"SNP_infos\",sep=\"/\"))\n        }\n        save(scores.info,file=paste(output.dir,\"/SNP_infos/\",\"SNP.infos.\",chromosome.id[f],\".Rdata\",sep=\"\"))\n        coh@SNP.infos = c(coh@SNP.infos,paste(output.dir,\"/SNP_infos/\",\"SNP.infos.\",chromosome.id[f],\".Rdata\",sep=\"\"))\n      }else{\n        warning(\"Some of the files provided did not exist\")\n      }\n    }\n    saveRDS(coh,file=paste(output.dir,\"/cohort.RDS\",sep=\"\"))\n    return(coh)\n  }else{\n    stop(\"For every genotype file there should be a coresponding SNPTEST result file.\")\n  }\n}\n\n# loads a previously saved cohort located in the directory \"out.dir\".\n# The file must be named cohort.RDS (case sensitive)\nload.cohort = function(out.dir){\n  setClass(\"cohort\", \n           slots=c(name=\"character\",type=\"character\",map=\"data.frame\",\n                   output.dir=\"character\",SNP.infos=\"character\"),\n           prototype=c(name=\"\",type=\"\",map=data.frame(),output.dir=\"\",\n                       SNP.infos=c()))\n  coh = readRDS(file=paste(out.dir,\"/cohort.RDS\",sep=\"\"))\n  coh\n}\n\n# Retrieve all SNP rsids and p-values for a cohort \n# or from the SNPTEST output files. \n# This can be used to create a SNP database. \n# Returned is a vector of p-values and the rsids \n# as names for the elements in the vector. \nget.all.SNPs = function(gwps=NULL,p.value.threshold=0.05){\n  ps = NULL\n  if(is.null(gwps)|class(gwps)[1]!=\"GWPS\"){\n    stop(\"Please provide a GWPS object as provided by the \\\"GWPS\\\" function.\")\n  }else{\n    cohort1 = gwps@cohort1\n    SNP.infos.files = cohort1@SNP.infos\n    SNPs = c()\n    ps = c()\n    ps = unlist(lapply(SNP.infos.files,function(file.name){\n      load(file = file.name)\n      indexes = which(as.numeric(scores.info[,\"p-values\"])<=p.value.threshold)\n      ps = as.numeric(scores.info[indexes,\"p-values\"])\n      names(ps) = scores.info[indexes,\"rsid\"]\n      ps\n    }))\n  }\n  ps\n}\n\n#Create and return a GWPS object\nGWPS = function(cohort1,cohort2,out.dir,name=\"\",description=\"\"){\n  setClass(\"cohort\", \n           slots=c(name=\"character\",type=\"character\",map=\"data.frame\",\n                   output.dir=\"character\",SNP.infos=\"character\"),\n           prototype=c(name=\"\",type=\"\",map=data.frame(),output.dir=\"\",\n                       SNP.infos=c()))\n  setClass(\"GWPS\", \n           slots=c(name=\"character\",output.dir=\"character\",\n                   cohort1=\"cohort\",cohort2=\"cohort\",\n                   description=\"character\"),\n           prototype=c(name=\"\",type=\"\",output.dir=\"\",\n                       cohort1=new(\"cohort\"),cohort2=new(\"cohort\"),\n                       description=\"\"))\n  gwps = new(\"GWPS\")\n  if(name==\"\"){\n    warning(\"A name should be provided to distinguish this \n            GWPS object later from other analysis.\")\n  }else{\n    gwps@name = name\n  }\n  if(description==\"\"){\n    warning(\"A description should be provided to distinguish this \n            GWPS object later from other analysis.\")\n  }else{\n    gwps@description = description\n  }\n  if(class(cohort1)[1]==\"cohort\"&class(cohort2)[1]==\"cohort\"){\n    gwps@cohort1 = cohort1\n    gwps@cohort2 = cohort2\n  }else{\n    stop(\"Please provide a cohort object as provided by the \n         function \\\"get.cohort\\\" or \\\"load.cohort\\\" for both \n         (cohort1 and cohort2) input variables.\")\n  }\n  if(!file.exists(out.dir)){\n    dir.create(out.dir)\n  }\n  gwps@output.dir = out.dir\n  saveRDS(gwps,file=paste(out.dir,\"GWPS.RDS\",sep=\"/\"))\n  gwps\n}\n\nmerge.cohorts = function(cohort1,cohort2,outdir.new,name=\"\"){\n  setClass(\"cohort\", \n           slots=c(name=\"character\",type=\"character\",map=\"data.frame\",\n                   output.dir=\"character\",SNP.infos=\"character\"),\n           prototype=c(name=\"\",type=\"\",map=data.frame(),output.dir=\"\",\n                       SNP.infos=c()))\n  coh = new(\"cohort\")\n  if(cohort1@type==cohort2@type){\n    coh@type = cohort1@type\n    if(!file.exists(outdir.new)){\n      dir.create(outdir.new)\n    }\n    if(name==\"\"){\n      name = paste(cohort1@name,cohort2@name,sep=\"_\")\n    }\n    coh@name = name\n    if(length(which(as.character(unlist(cohort1@map[1,]))%in%as.character(unlist(cohort2@map[1,]))))>0&\n         length(which(as.character(unlist(cohort1@map[2,]))%in%as.character(unlist(cohort2@map[2,]))))){\n      warning(\"The id's for the samples where not unique in the cohort to merge.\")\n    }\n    coh@map = merge(cohort1@map, cohort2@map, by=\"row.names\", all=TRUE)\n    rownames(coh@map) = coh@map[,1]\n    coh@map = coh@map[,-1]\n    order = c(which(rownames(coh@map)%in%c(\"ID_1\",\"ID_2\",\"missing\")),\n              which(!rownames(coh@map)%in%c(\"ID_1\",\"ID_2\",\"missing\")))\n    if(length(order)<nrow(coh@map)){\n      stop(\"Something was wrong with the map data.frame. \n           This data.frame should always contain the row \n           names \\\"ID_1\\\", \\\"ID_2\\\" and \\\"missing\\\".\")\n    }\n    coh@map = coh@map[order,]\n    coh@output.dir = outdir.new\n    if(length(basename(cohort1@SNP.infos)%in%basename(cohort2@SNP.infos))!=length(cohort1@SNP.infos)){\n      stop(\"The two cohorts have different names for there data origin. \n           Therefore it is not possible to find matching pairs.\")\n    }\n    SNP_infos.dir = paste(outdir.new,\"SNP_infos\",sep=\"/\")\n    if(!file.exists(paste(outdir.new,\"SNP_infos\",sep=\"/\"))){\n      dir.create(SNP_infos.dir)\n    }\n    scores.dir = paste(outdir.new,\"scores\",sep=\"/\")\n    if(!file.exists(paste(outdir.new,\"scores\",sep=\"/\"))){\n      dir.create(scores.dir)\n    }\n    SNP.infos =c()\n    for(index in 1:length(cohort1@SNP.infos)){\n      load(file=cohort1@SNP.infos[index])\n      info1 = scores.info\n      load(file=cohort2@SNP.infos[index])\n      chunks1 = unique(info1[,\"chunk.file\"])\n      chunks2 = unique(scores.info[,\"chunk.file\"])\n      if(length(chunks1)!=length(chunks2)){\n        stop(\"Different number of chunks for an input file.\")\n      }\n      for(chunk.index in 1:length(chunks1)){\n        load(file=chunks1[chunk.index])\n        scores1 = scores\n        load(file=chunks2[chunk.index])\n        scores2 = scores\n        scores = cbind(scores1,scores)\n        new.chunk.file = paste(scores.dir,basename(chunks1[chunk.index]),sep=\"/\")\n        info1[which(info1[,\"chunk.file\"]%in%chunks1[chunk.index]),\"chunk.file\"] = new.chunk.file\n        save(scores,file=new.chunk.file)\n      }\n      scores.info = info1\n      new.SNP.info.file = paste(SNP_infos.dir,basename(cohort1@SNP.infos[index]),sep=\"/\")\n      SNP.infos = c(SNP.infos,new.SNP.info.file)\n      save(scores.info,file=new.SNP.info.file)\n    }\n    coh@SNP.infos = SNP.infos\n    saveRDS(coh,file=paste(outdir.new,\"/cohort.RDS\",sep=\"\"))\n  }else{\n    stop(\"Cohorts need to be of the same type to merge them.\")\n  }\n  coh\n}\n\n# loads an gwps object sitting in the specified directory \"GWPS.dir\". It must be called \n# GWPS.RDS (case sensitive)\nload.GWPS = function(GWPS.dir){\n  setClass(\"cohort\", \n           slots=c(name=\"character\",type=\"character\",map=\"data.frame\",\n                   output.dir=\"character\",SNP.infos=\"character\"),\n           prototype=c(name=\"\",type=\"\",map=data.frame(),output.dir=\"\",\n                       SNP.infos=c()))\n  setClass(\"GWPS\", \n           slots=c(name=\"character\",output.dir=\"character\",\n                   cohort1=\"cohort\",cohort2=\"cohort\",\n                   description=\"character\"),\n           prototype=c(name=\"\",type=\"\",output.dir=\"\",\n                       cohort1=new(\"cohort\"),cohort2=new(\"cohort\"),\n                       description=\"\"))\n  gwps = NULL\n  if(file.exists(paste(GWPS.dir,\"GWPS.RDS\",sep=\"/\"))){\n    gwps = readRDS(paste(GWPS.dir,\"GWPS.RDS\",sep=\"/\"))\n  }else{\n    stop(\"Specified directory does not contain an GWPS analysis\")\n  }\n  gwps\n}\n\n\n\n#test 1: A rather small file.\n# setwd(\"/media/christoph/0357FCFC5DF93E00/\")\n# system.time({test.cohort = get.cohort(GT_calls=\"data/Cases/calls/UC_0Y_affymetrix.gen.gz\",\n#                          threshold=1,\n#                          map=\"data/Cases/UC_affymetrix.sample\",\n#                          ind.remove=scan(file=\"data/exclude_INDs/ALL_affymetrix_indiv.exclude.all_new.txt\",\n#                                          what=\"character\",\n#                                          sep=\"\\n\"),\n#                          SNPTEST.clean=\"snptest_new_run_2/UC_chr0Y-newml.txt\",\n#                          chromosome.id=\"0Y\",\n#                          output=T,\n#                          type = \"control\",\n#                          output.dir=\"test\",\n#                          name=\"test\")})\n\n#test 2: A small to medium sized file.\n# system.time({test.cohort = get.cohort(GT_calls=\"data/NBS/calls/NBS_22_affymetrix.gen.gz\",\n#                                       threshold=1,\n#                                       map=\"data/NBS/NBS_affymetrix.sample\",\n#                                       ind.remove=scan(file=\"data/exclude_INDs/ALL_affymetrix_indiv.exclude.all_new.txt\",\n#                                                       what=\"character\",\n#                                                       sep=\"\\n\"),\n#                                       SNPTEST.clean=\"snptest_new_run_2/UC_chr22-score.txt\",\n#                                       chromosome.id=\"22\",\n#                                       output=T,\n#                                       type = \"control\",\n#                                       output.dir=\"test\",\n#                                       name=\"test\")})\n\n#test 3: Both files fron test 1 and 2.\n# system.time({test.cohort = get.cohort(GT_calls=c(\"data/1958BC/calls/58C_0Y_affymetrix.gen.gz\",\n#                                                  \"data/1958BC/calls/58C_22_affymetrix.gen.gz\"),\n#                                       threshold=1,\n#                                       map=\"data/1958BC/calls/58C_affymetrix.sample\",\n#                                       ind.remove=scan(file=\"exclude_INDs/ALL_affymetrix_indiv.exclude.all.txt\",\n#                                                       what=\"character\",\n#                                                       sep=\"\\n\"),\n#                                       SNPTEST.clean=c(\"SNPTEST_frequentist_score/UC_chr0Y-expected.txt\",\n#                                                       \"SNPTEST_frequentist_score/UC_chr22-expected.txt\"),\n#                                       chromosome.id=c(\"0Y\",\"22\"),\n#                                       output=T,\n#                                       type = \"control\",\n#                                       output.dir=\"test\",\n#                                       name=\"test\",\n#                                       run.again=test.cohort)})\n\n#test 4: profiling with test 1\n# Rprof()\n# for(i in 1:20){\n#   test.cohort = get.cohort(GT_calls=\"data/1958BC/calls/58C_0Y_affymetrix.gen.gz\",\n#                            threshold=1,\n#                            map=\"data/1958BC/calls/58C_affymetrix.sample\",\n#                            ind.remove=scan(file=\"exclude_INDs/ALL_affymetrix_indiv.exclude.all.txt\",\n#                                            what=\"character\",\n#                                            sep=\"\\n\"),\n#                            SNPTEST.clean=\"SNPTEST_frequentist_score/UC_chr0Y-expected.txt\",\n#                            chromosome.id=\"0Y\",\n#                            output=F,\n#                            type = \"control\",\n#                            output.dir=\"test\",\n#                            name=\"test\")\n# }\n# Rprof(NULL)\n# prof = summaryRprof()\n# prof$by.self\n\n# self.time self.pct total.time total.pct\n# \"FUN\"                      483.62    39.73    1114.48     91.56\n# \">=\"                       283.94    23.33     283.94     23.33\n# \"which\"                    143.90    11.82     430.28     35.35\n# \"lapply\"                    59.12     4.86    1114.52     91.57\n# \"scan\"                      51.92     4.27      51.92      4.27\n# \"c\"                         31.40     2.58      31.40      2.58\n# \"==\"                        26.76     2.20      26.76      2.20\n# \"&\"                         17.84     1.47      17.84      1.47\n# \"<Anonymous>\"               10.24     0.84      11.16      0.92\n# \"length\"                    10.10     0.83      10.10      0.83\n# \":\"                          8.86     0.73       8.86      0.73\n# \"match\"                      7.48     0.61      27.02      2.22\n# \"get.scores\"                 7.20     0.59    1209.76     99.39\n# \"[.data.frame\"               6.88     0.57      42.94      3.53\n# \"|\"                          5.70     0.47       5.70      0.47\n# \"+\"                          5.18     0.43       5.18      0.43\n# \"matrix\"                     5.18     0.43       5.18      0.43\n# \"[[.data.frame\"              4.42     0.36      16.68      1.37\n# \"[[\"                         3.66     0.30      20.34      1.67\n# \"unlist\"                     3.24     0.27     962.04     79.04\n# \"NextMethod\"                 3.08     0.25       3.10      0.25\n# \"[.factor\"                   2.72     0.22       9.34      0.77\n# \"%in%\"                       2.62     0.22      28.04      2.30\n# \"(\"                          2.54     0.21       2.54      0.21\n# \"levels\"                     2.28     0.19       2.88      0.24\n# \"pmin\"                       2.20     0.18       2.54      0.21\n# \"all\"                        1.94     0.16       1.94      0.16\n# \"dim\"                        1.88     0.15       1.88      0.15\n# \"is.factor\"                  1.84     0.15       1.84      0.15\n# \"[\"                          1.70     0.14      43.72      3.59\n# \"*\"                          1.64     0.13       1.64      0.13\n# \"unique\"                     1.42     0.12       3.30      0.27\n# \"sys.call\"                   1.40     0.12       1.40      0.12\n# \"names\"                      1.38     0.11       1.38      0.11\n# \"attr\"                       0.92     0.08       0.92      0.08\n# \"factor\"                     0.90     0.07       8.18      0.67\n# \".subset2\"                   0.76     0.06       0.76      0.06\n# \"seq\"                        0.74     0.06       4.06      0.33\n# \"array\"                      0.70     0.06       0.70      0.06\n# \"seq.default\"                0.62     0.05       3.32      0.27\n# \"unique.default\"             0.54     0.04       1.84      0.15\n# \"t.default\"                  0.48     0.04       0.48      0.04\n# \"deparse\"                    0.44     0.04       1.38      0.11\n# \"sort.list\"                  0.42     0.03       2.62      0.22\n# \"levels.default\"             0.36     0.03       0.60      0.05\n# \"-\"                          0.32     0.03       0.32      0.03\n# \"rownames<-\"                 0.32     0.03       0.32      0.03\n# \"eval\"                       0.30     0.02       1.78      0.15\n# \"match.arg\"                  0.28     0.02       2.18      0.18\n# \"is.matrix\"                  0.26     0.02       0.26      0.02\n# \"estimate.scores\"            0.24     0.02    1075.02     88.32\n# \".deparseOpts\"               0.24     0.02       0.56      0.05\n# \"as.data.frame.matrix\"       0.22     0.02       8.98      0.74\n# \".subset\"                    0.22     0.02       0.22      0.02\n# \"as.vector\"                  0.18     0.01       0.48      0.04\n# \"anyDuplicated\"              0.18     0.01       0.24      0.02\n# \"make.names\"                 0.18     0.01       0.18      0.01\n# \"nargs\"                      0.18     0.01       0.18      0.01\n# \"pmatch\"                     0.14     0.01       0.22      0.02\n# \"match.fun\"                  0.14     0.01       0.16      0.01\n# \".External2\"                 0.12     0.01       0.12      0.01\n# \"prettyNum\"                  0.12     0.01       0.12      0.01\n# \"vapply\"                     0.10     0.01       0.24      0.02\n# \"as.character\"               0.10     0.01       0.10      0.01\n# \"max\"                        0.08     0.01       0.08      0.01\n# \"sum\"                        0.08     0.01       0.08      0.01\n# \"data.frame\"                 0.06     0.00       9.40      0.77\n# \"as.factor\"                  0.06     0.00       8.76      0.72\n# \"mode\"                       0.06     0.00       0.10      0.01\n# \"any\"                        0.06     0.00       0.06      0.00\n# \"anyDuplicated.default\"      0.06     0.00       0.06      0.00\n# \"force\"                      0.04     0.00       0.08      0.01\n# \"formals\"                    0.04     0.00       0.08      0.01\n# \"rownames\"                   0.04     0.00       0.06      0.00\n# \"is.na\"                      0.04     0.00       0.04      0.00\n# \"is.ordered\"                 0.04     0.00       0.04      0.00\n# \"mostattributes<-\"           0.04     0.00       0.04      0.00\n# \"oldClass\"                   0.04     0.00       0.04      0.00\n# \"parent.frame\"               0.04     0.00       0.04      0.00\n# \"get.cohort\"                 0.02     0.00    1217.16    100.00\n# \"read.table\"                 0.02     0.00       1.22      0.10\n# \"elNamed\"                    0.02     0.00       0.04      0.00\n# \"sys.function\"               0.02     0.00       0.04      0.00\n# \">\"                          0.02     0.00       0.02      0.00\n# \"assign\"                     0.02     0.00       0.02      0.00\n# \".Call\"                      0.02     0.00       0.02      0.00\n# \"dimnames\"                   0.02     0.00       0.02      0.00\n# \"el\"                         0.02     0.00       0.02      0.00\n# \".External\"                  0.02     0.00       0.02      0.00\n# \"getClassDef\"                0.02     0.00       0.02      0.00\n# \"is.atomic\"                  0.02     0.00       0.02      0.00\n# \"is.call\"                    0.02     0.00       0.02      0.00\n# \"is.expression\"              0.02     0.00       0.02      0.00\n# \"is.finite\"                  0.02     0.00       0.02      0.00\n# \"is.function\"                0.02     0.00       0.02      0.00\n# \"is.list\"                    0.02     0.00       0.02      0.00\n# \"seq_along\"                  0.02     0.00       0.02      0.00\n# \"sys.parent\"                 0.02     0.00       0.02      0.00\n\n# DO NOT RUN\n# Rprof()\n# for(i in 1:1000){\n#   scores = unlist(lapply(seq(from=1,by=3,to=length(row.gts)-5),\n#                          function(ind,row,threshold){\n#                            x = which(row[ind:(ind+2)]>=threshold)\n#                            if(length(x)==0){\n#                              x=NA\n#                            }\n#                            x\n#                          }\n#                          ,triplets,threshold))\n# }\n# Rprof(NULL)\n# prof = summaryRprof()\n# prof$by.self\n# \n",
    "created" : 1412115531884.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3747964998",
    "id" : "D94C7270",
    "lastKnownWriteTime" : 1412564546,
    "path" : "~/Dropbox/master/workspace/GWPS_R_scripts/getSet.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}